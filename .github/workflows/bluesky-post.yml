name: Post to BlueSky

on:
  workflow_call:
    inputs:
      post_text:
        description: 'The text content of the post. Supports markdown links [text](url) and hashtags.'
        required: true
        type: string
      embed_url:
        description: 'Optional URL to create a website card embed from'
        required: false
        type: string
      embed_title:
        description: 'Optional title for the embed card (avoids fetching from OG tags)'
        required: false
        type: string
      embed_description:
        description: 'Optional description for the embed card (avoids fetching from OG tags)'
        required: false
        type: string
      embed_image_url:
        description: 'Optional image URL for the embed card (avoids fetching from OG tags)'
        required: false
        type: string
    secrets:
      BLUESKY_USERNAME:
        required: true
      BLUESKY_APP_PASSWORD:
        required: true

jobs:
  post:
    runs-on: ubuntu-latest
    steps:
      - name: Post to BlueSky
        env:
          POST_INPUT: ${{ toJSON(inputs.post_text) }}
          EMBED_URL: ${{ inputs.embed_url }}
          EMBED_TITLE: ${{ inputs.embed_title }}
          EMBED_DESCRIPTION: ${{ inputs.embed_description }}
          EMBED_IMAGE_URL: ${{ inputs.embed_image_url }}
        run: |
          # Authenticate with BlueSky
          echo "Authenticating with BlueSky..."
          AUTH_RESPONSE=$(curl -s -X POST https://bsky.social/xrpc/com.atproto.server.createSession \
            -H "Content-Type: application/json" \
            -d "{\"identifier\": \"${{ secrets.BLUESKY_USERNAME }}\", \"password\": \"${{ secrets.BLUESKY_APP_PASSWORD }}\"}")

          ACCESS_TOKEN=$(echo "$AUTH_RESPONSE" | jq -r '.accessJwt')
          DID=$(echo "$AUTH_RESPONSE" | jq -r '.did')

          if [ -z "$ACCESS_TOKEN" ] || [ "$ACCESS_TOKEN" == "null" ]; then
            echo "Error: Failed to authenticate with BlueSky"
            echo "Response: $AUTH_RESPONSE"
            exit 1
          fi

          echo "✓ Authenticated as $DID"

          # Get current timestamp in ISO 8601 format
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          # Parse markdown links and calculate facets using Python
          echo "Parsing markdown and calculating facets..."

          RESULT=$(python3 << 'PYEOF'
          import json, re, os

          input_text = json.loads(os.environ['POST_INPUT'])

          # Parse markdown links [text](url) and build facets
          facets = []
          output_text = ''
          last_end = 0

          # Find all markdown links
          md_links = list(re.finditer(r'\[([^\]]+)\]\(([^)]+)\)', input_text))

          for m in md_links:
              # Add text before this link
              output_text += input_text[last_end:m.start()]
              link_text = m.group(1)
              link_url = m.group(2)

              # Calculate byte position in output text
              byte_start = len(output_text.encode('utf-8'))
              output_text += link_text
              byte_end = len(output_text.encode('utf-8'))

              facets.append({
                  'index': {'byteStart': byte_start, 'byteEnd': byte_end},
                  'features': [{'$type': 'app.bsky.richtext.facet#link', 'uri': link_url}]
              })

              last_end = m.end()

          # Add remaining text
          output_text += input_text[last_end:]

          # Add hashtag facets
          for m in re.finditer(r'#(\w+)', output_text):
              facets.append({
                  'index': {'byteStart': len(output_text[:m.start()].encode('utf-8')), 'byteEnd': len(output_text[:m.end()].encode('utf-8'))},
                  'features': [{'$type': 'app.bsky.richtext.facet#tag', 'tag': m.group(1)}]
              })

          # Add bare URL facets
          for m in re.finditer(r'https?://[^\s]+', output_text):
              byte_start = len(output_text[:m.start()].encode('utf-8'))
              byte_end = len(output_text[:m.end()].encode('utf-8'))
              # Skip if this position overlaps with an existing link facet
              already_linked = any(
                  f['index']['byteStart'] <= byte_start and f['index']['byteEnd'] >= byte_end
                  for f in facets if any(feat.get('uri') for feat in f['features'])
              )
              if not already_linked:
                  facets.append({
                      'index': {'byteStart': byte_start, 'byteEnd': byte_end},
                      'features': [{'$type': 'app.bsky.richtext.facet#link', 'uri': m.group()}]
                  })

          # Output as JSON object with both text and facets
          print(json.dumps({'text': output_text, 'facets': facets}))
          PYEOF
          )

          POST_TEXT=$(echo "$RESULT" | jq -r '.text')
          FACETS=$(echo "$RESULT" | jq -c '.facets')

          echo "Post text: $POST_TEXT"
          echo "Facets: $FACETS"

          # Build embed if URL provided
          EMBED=""
          if [ -n "$EMBED_URL" ]; then
            # Use provided metadata or fetch from OG tags
            OG_TITLE="$EMBED_TITLE"
            OG_DESC="$EMBED_DESCRIPTION"
            OG_IMAGE="$EMBED_IMAGE_URL"

            # Only fetch OG tags if we're missing required metadata
            if [ -z "$OG_TITLE" ] || [ -z "$OG_IMAGE" ]; then
              echo "Fetching OG tags from: $EMBED_URL"

              # Fetch page and extract OG tags using Python
              EMBED_DATA=$(python3 << 'PYEOF'
          import urllib.request
          import re
          import json
          import os
          import sys

          url = os.environ.get('EMBED_URL', '')
          if not url:
              print(json.dumps({}))
              sys.exit(0)

          try:
              req = urllib.request.Request(url, headers={'User-Agent': 'Mozilla/5.0'})
              with urllib.request.urlopen(req, timeout=10) as response:
                  html = response.read().decode('utf-8', errors='ignore')

              # Extract OG tags using backreferences to handle quotes in content
              og_title = re.search(r'<meta[^>]*property=["\']og:title["\'][^>]*content=(["\'])(.+?)\1', html, re.I)
              og_title = og_title.group(2) if og_title else ''

              og_desc = re.search(r'<meta[^>]*property=["\']og:description["\'][^>]*content=(["\'])(.+?)\1', html, re.I)
              og_desc = og_desc.group(2) if og_desc else ''

              og_image = re.search(r'<meta[^>]*property=["\']og:image["\'][^>]*content=(["\'])(.+?)\1', html, re.I)
              og_image = og_image.group(2) if og_image else ''

              print(json.dumps({'title': og_title, 'description': og_desc, 'image': og_image}))
          except Exception as e:
              print(json.dumps({'error': str(e)}), file=sys.stderr)
              print(json.dumps({}))
          PYEOF
              )

              # Use fetched values only for missing metadata
              [ -z "$OG_TITLE" ] && OG_TITLE=$(echo "$EMBED_DATA" | jq -r '.title // empty')
              [ -z "$OG_DESC" ] && OG_DESC=$(echo "$EMBED_DATA" | jq -r '.description // empty')
              [ -z "$OG_IMAGE" ] && OG_IMAGE=$(echo "$EMBED_DATA" | jq -r '.image // empty')
            else
              echo "Using provided embed metadata"
            fi

            echo "Embed Title: $OG_TITLE"
            echo "Embed Description: $OG_DESC"
            echo "Embed Image: $OG_IMAGE"

            if [ -n "$OG_TITLE" ]; then
              # Upload image as blob if present
              THUMB_JSON=""
              if [ -n "$OG_IMAGE" ]; then
                echo "Downloading image: $OG_IMAGE"
                curl -s -L -o /tmp/og_image "$OG_IMAGE"

                if [ -f /tmp/og_image ] && [ -s /tmp/og_image ]; then
                  # Detect mime type
                  MIME_TYPE=$(file --mime-type -b /tmp/og_image)
                  echo "Image MIME type: $MIME_TYPE"

                  # Upload blob
                  echo "Uploading image blob..."
                  BLOB_RESPONSE=$(curl -s -X POST https://bsky.social/xrpc/com.atproto.repo.uploadBlob \
                    -H "Content-Type: $MIME_TYPE" \
                    -H "Authorization: Bearer $ACCESS_TOKEN" \
                    --data-binary @/tmp/og_image)

                  BLOB_REF=$(echo "$BLOB_RESPONSE" | jq -c '.blob')
                  if [ "$BLOB_REF" != "null" ] && [ -n "$BLOB_REF" ]; then
                    echo "Blob uploaded successfully"
                    THUMB_JSON="$BLOB_REF"
                  else
                    echo "Failed to upload blob: $BLOB_RESPONSE"
                  fi
                fi
              fi

              # Build embed object
              if [ -n "$THUMB_JSON" ]; then
                EMBED=$(jq -n \
                  --arg uri "$EMBED_URL" \
                  --arg title "$OG_TITLE" \
                  --arg desc "$OG_DESC" \
                  --argjson thumb "$THUMB_JSON" \
                  '{
                    "$type": "app.bsky.embed.external",
                    "external": {
                      "uri": $uri,
                      "title": $title,
                      "description": $desc,
                      "thumb": $thumb
                    }
                  }')
              else
                EMBED=$(jq -n \
                  --arg uri "$EMBED_URL" \
                  --arg title "$OG_TITLE" \
                  --arg desc "$OG_DESC" \
                  '{
                    "$type": "app.bsky.embed.external",
                    "external": {
                      "uri": $uri,
                      "title": $title,
                      "description": $desc
                    }
                  }')
              fi
              echo "Embed created"
            fi
          fi

          # Create the post using jq to properly escape JSON
          echo "Creating BlueSky post..."
          if [ -n "$EMBED" ]; then
            POST_RESPONSE=$(jq -n \
              --arg did "$DID" \
              --arg text "$POST_TEXT" \
              --arg timestamp "$TIMESTAMP" \
              --argjson facets "$FACETS" \
              --argjson embed "$EMBED" \
              '{
                repo: $did,
                collection: "app.bsky.feed.post",
                record: {
                  text: $text,
                  facets: $facets,
                  embed: $embed,
                  createdAt: $timestamp,
                  "$type": "app.bsky.feed.post"
                }
              }' | curl -s -X POST https://bsky.social/xrpc/com.atproto.repo.createRecord \
              -H "Content-Type: application/json" \
              -H "Authorization: Bearer $ACCESS_TOKEN" \
              -d @-)
          else
            POST_RESPONSE=$(jq -n \
              --arg did "$DID" \
              --arg text "$POST_TEXT" \
              --arg timestamp "$TIMESTAMP" \
              --argjson facets "$FACETS" \
              '{
                repo: $did,
                collection: "app.bsky.feed.post",
                record: {
                  text: $text,
                  facets: $facets,
                  createdAt: $timestamp,
                  "$type": "app.bsky.feed.post"
                }
              }' | curl -s -X POST https://bsky.social/xrpc/com.atproto.repo.createRecord \
              -H "Content-Type: application/json" \
              -H "Authorization: Bearer $ACCESS_TOKEN" \
              -d @-)
          fi

          POST_URI=$(echo "$POST_RESPONSE" | jq -r '.uri')

          if [ -z "$POST_URI" ] || [ "$POST_URI" == "null" ]; then
            echo "Error: Failed to create BlueSky post"
            echo "Response: $POST_RESPONSE"
            exit 1
          fi

          # Extract the post ID from the URI
          POST_ID=$(echo "$POST_URI" | sed 's|.*/||')
          POST_URL="https://bsky.app/profile/${{ secrets.BLUESKY_USERNAME }}/post/$POST_ID"

          echo "✓ Posted to BlueSky: $POST_URL"
        shell: bash
